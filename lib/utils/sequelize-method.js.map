{
  "version": 3,
  "sources": ["../../src/utils/sequelize-method.ts"],
  "sourcesContent": ["import isObject from 'lodash/isObject';\nimport type { Op, WhereOperators, WhereLeftOperand, WhereAttributeHash, WhereAttributeHashValue } from '..';\n\n/**\n * Utility functions for representing SQL functions, and columns that should be escaped.\n * Please do not use these functions directly, use Sequelize.fn and Sequelize.col instead.\n *\n * @private\n */\nexport class SequelizeMethod {}\n\n/**\n * Do not use me directly. Use {@link Sequelize.fn}\n */\nexport class Fn extends SequelizeMethod {\n  private readonly fn: string;\n\n  // unknown already covers the other two types, but they've been added explicitly to document\n  // passing WhereAttributeHash generates a condition inside the function.\n  private readonly args: Array<unknown | SequelizeMethod | WhereAttributeHash>;\n\n  constructor(fn: string, args: Fn['args']) {\n    super();\n    this.fn = fn;\n    this.args = args;\n  }\n\n  clone(): Fn {\n    return new Fn(this.fn, this.args);\n  }\n}\n\n/**\n * Do not use me directly. Use {@link Sequelize.col}\n */\nexport class Col extends SequelizeMethod {\n  private readonly col: string[] | string;\n\n  constructor(col: string[] | string, ...args: string[]) {\n    super();\n    // TODO(ephys): this does not look right. First parameter is ignored if a second parameter is provided.\n    //  should we change the signature to `constructor(...cols: string[])`\n    if (args.length > 0) {\n      col = args;\n    }\n\n    this.col = col;\n  }\n}\n\n/**\n * Do not use me directly. Use {@link Sequelize.cast}\n */\nexport class Cast extends SequelizeMethod {\n  private readonly val: any;\n  private readonly type: string;\n  private readonly json: boolean;\n\n  constructor(val: unknown, type: string = '', json: boolean = false) {\n    super();\n    this.val = val;\n    this.type = type.trim();\n    this.json = json;\n  }\n}\n\n/**\n * Do not use me directly. Use {@link Sequelize.literal}\n */\nexport class Literal extends SequelizeMethod {\n  /** this (type-only) brand prevents TypeScript from thinking Cast is assignable to Literal because they share the same shape */\n  declare private readonly brand: 'literal';\n\n  private readonly val: unknown;\n\n  constructor(val: unknown) {\n    super();\n    this.val = val;\n  }\n}\n\n/**\n * Do not use me directly. Use {@link Sequelize.json}\n */\nexport class Json extends SequelizeMethod {\n  private readonly conditions?: { [key: string]: any };\n  private readonly path?: string;\n  private readonly value?: string | number | boolean | null;\n\n  constructor(\n    conditionsOrPath: { [key: string]: any } | string,\n    value?: string | number | boolean | null,\n  ) {\n    super();\n\n    if (typeof conditionsOrPath === 'string') {\n      this.path = conditionsOrPath;\n\n      if (value) {\n        this.value = value;\n      }\n    } else if (isObject(conditionsOrPath)) {\n      this.conditions = conditionsOrPath;\n    }\n  }\n}\n\n/**\n * Do not use me directly. Use {@link Sequelize.where}\n */\nexport class Where<Operator extends keyof WhereOperators = typeof Op.eq> extends SequelizeMethod {\n  // TODO [=7]: rename to leftOperand after typescript migration\n  private readonly attribute: WhereLeftOperand;\n  // TODO [=7]: rename to operator after typescript migration\n  private readonly comparator: string | Operator;\n  // TODO [=7]: rename to rightOperand after typescript migration\n  private readonly logic: WhereOperators[Operator] | WhereAttributeHashValue<any> | any;\n\n  constructor(leftOperand: WhereLeftOperand, operator: Operator, rightOperand: WhereOperators[Operator]);\n  constructor(leftOperand: WhereLeftOperand, operator: string, rightOperand: any);\n  constructor(leftOperand: WhereLeftOperand, rightOperand: WhereAttributeHashValue<any>);\n  constructor(\n    leftOperand: WhereLeftOperand,\n    operatorOrRightOperand: string | Operator | WhereAttributeHashValue<any>,\n    rightOperand?: WhereOperators[Operator] | any,\n  ) {\n    super();\n\n    this.attribute = leftOperand;\n\n    if (rightOperand !== undefined) {\n      this.logic = rightOperand;\n      this.comparator = operatorOrRightOperand;\n    } else {\n      this.logic = operatorOrRightOperand;\n      this.comparator = '=';\n    }\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAAqB;AASd,MAAM,gBAAgB;AAAC;AAKvB,MAAM,WAAW,gBAAgB;AAAA,EACrB;AAAA,EAIA;AAAA,EAEjB,YAAY,IAAY,MAAkB;AACxC,UAAM;AACN,SAAK,KAAK;AACV,SAAK,OAAO;AAAA,EACd;AAAA,EAEA,QAAY;AACV,WAAO,IAAI,GAAG,KAAK,IAAI,KAAK,IAAI;AAAA,EAClC;AACF;AAKO,MAAM,YAAY,gBAAgB;AAAA,EACtB;AAAA,EAEjB,YAAY,QAA2B,MAAgB;AACrD,UAAM;AAGN,QAAI,KAAK,SAAS,GAAG;AACnB,YAAM;AAAA,IACR;AAEA,SAAK,MAAM;AAAA,EACb;AACF;AAKO,MAAM,aAAa,gBAAgB;AAAA,EACvB;AAAA,EACA;AAAA,EACA;AAAA,EAEjB,YAAY,KAAc,OAAe,IAAI,OAAgB,OAAO;AAClE,UAAM;AACN,SAAK,MAAM;AACX,SAAK,OAAO,KAAK,KAAK;AACtB,SAAK,OAAO;AAAA,EACd;AACF;AAKO,MAAM,gBAAgB,gBAAgB;AAAA,EAI1B;AAAA,EAEjB,YAAY,KAAc;AACxB,UAAM;AACN,SAAK,MAAM;AAAA,EACb;AACF;AAKO,MAAM,aAAa,gBAAgB;AAAA,EACvB;AAAA,EACA;AAAA,EACA;AAAA,EAEjB,YACE,kBACA,OACA;AACA,UAAM;AAEN,QAAI,OAAO,qBAAqB,UAAU;AACxC,WAAK,OAAO;AAEZ,UAAI,OAAO;AACT,aAAK,QAAQ;AAAA,MACf;AAAA,IACF,WAAW,6BAAS,gBAAgB,GAAG;AACrC,WAAK,aAAa;AAAA,IACpB;AAAA,EACF;AACF;AAKO,MAAM,cAAoE,gBAAgB;AAAA,EAE9E;AAAA,EAEA;AAAA,EAEA;AAAA,EAKjB,YACE,aACA,wBACA,cACA;AACA,UAAM;AAEN,SAAK,YAAY;AAEjB,QAAI,iBAAiB,QAAW;AAC9B,WAAK,QAAQ;AACb,WAAK,aAAa;AAAA,IACpB,OAAO;AACL,WAAK,QAAQ;AACb,WAAK,aAAa;AAAA,IACpB;AAAA,EACF;AACF;",
  "names": []
}
