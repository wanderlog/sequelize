{
  "version": 3,
  "sources": ["../../src/utils/string.ts"],
  "sourcesContent": ["import _inflection from 'inflection';\n\n/* Inflection */\ntype Inflection = typeof _inflection;\n\nlet inflection: Inflection = _inflection;\n\nexport function useInflection(newInflection: Inflection) {\n  inflection = newInflection;\n}\n\n/* String utils */\n\nexport function camelizeIf(str: string, condition: boolean): string {\n  let result = str;\n\n  if (condition) {\n    result = camelize(str);\n  }\n\n  return result;\n}\n\nexport function camelize(str: string): string {\n  return str.trim().replace(/[-_\\s]+(.)?/g, (match, c) => c.toUpperCase());\n}\n\nexport function underscoredIf(str: string, condition: boolean): string {\n  let result = str;\n\n  if (condition) {\n    result = underscore(str);\n  }\n\n  return result;\n}\n\nexport function underscore(str: string): string {\n  return inflection.underscore(str);\n}\n\nexport function spliceStr(\n  str: string,\n  index: number,\n  count: number,\n  add: string,\n): string {\n  return str.slice(0, index) + add + str.slice(index + count);\n}\n\nexport function singularize(str: string): string {\n  return inflection.singularize(str);\n}\n\nexport function pluralize(str: string): string {\n  return inflection.pluralize(str);\n}\n\ntype NameIndexIndex = {\n  fields: Array<{ name: string, attribute: string }>,\n  name: string,\n};\ntype NameIndexTableName = string | { tableName: string };\n\n/**\n *\n * @param index\n * @param index.fields\n * @param index.name\n * @param tableName\n *\n * @private\n */\nexport function nameIndex(\n  index: NameIndexIndex,\n  tableName: NameIndexTableName,\n) {\n  if (typeof tableName !== 'string' && tableName.tableName) {\n    tableName = tableName.tableName;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(index, 'name')) {\n    const fields = index.fields.map(field => (typeof field === 'string' ? field : field.name || field.attribute));\n    index.name = underscore(`${tableName}_${fields.join('_')}`);\n  }\n\n  return index;\n}\n\n/**\n * Stringify a value as JSON with some differences:\n * - bigints are stringified as a json string. (`safeStringifyJson({ val: 1n })` outputs `'{ \"val\": \"1\" }'`).\n *   This is because of a decision by TC39 to not support bigint in JSON.stringify https://github.com/tc39/proposal-bigint/issues/24\n *\n * @param stringifyTarget the value to stringify.\n * @returns the resulting json.\n */\nexport function safeStringifyJson(stringifyTarget: any): string {\n  return JSON.stringify(stringifyTarget, (key, value) => {\n    if (typeof value === 'bigint') {\n      return String(value);\n    }\n\n    return value;\n  });\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAwB;AAKxB,IAAI,aAAyB;AAEtB,uBAAuB,eAA2B;AACvD,eAAa;AACf;AAIO,oBAAoB,KAAa,WAA4B;AAClE,MAAI,SAAS;AAEb,MAAI,WAAW;AACb,aAAS,SAAS,GAAG;AAAA,EACvB;AAEA,SAAO;AACT;AAEO,kBAAkB,KAAqB;AAC5C,SAAO,IAAI,KAAK,EAAE,QAAQ,gBAAgB,CAAC,OAAO,MAAM,EAAE,YAAY,CAAC;AACzE;AAEO,uBAAuB,KAAa,WAA4B;AACrE,MAAI,SAAS;AAEb,MAAI,WAAW;AACb,aAAS,WAAW,GAAG;AAAA,EACzB;AAEA,SAAO;AACT;AAEO,oBAAoB,KAAqB;AAC9C,SAAO,WAAW,WAAW,GAAG;AAClC;AAEO,mBACL,KACA,OACA,OACA,KACQ;AACR,SAAO,IAAI,MAAM,GAAG,KAAK,IAAI,MAAM,IAAI,MAAM,QAAQ,KAAK;AAC5D;AAEO,qBAAqB,KAAqB;AAC/C,SAAO,WAAW,YAAY,GAAG;AACnC;AAEO,mBAAmB,KAAqB;AAC7C,SAAO,WAAW,UAAU,GAAG;AACjC;AAiBO,mBACL,OACA,WACA;AACA,MAAI,OAAO,cAAc,YAAY,UAAU,WAAW;AACxD,gBAAY,UAAU;AAAA,EACxB;AAEA,MAAI,CAAC,OAAO,UAAU,eAAe,KAAK,OAAO,MAAM,GAAG;AACxD,UAAM,SAAS,MAAM,OAAO,IAAI,WAAU,OAAO,UAAU,WAAW,QAAQ,MAAM,QAAQ,MAAM,SAAU;AAC5G,UAAM,OAAO,WAAW,GAAG,aAAa,OAAO,KAAK,GAAG,GAAG;AAAA,EAC5D;AAEA,SAAO;AACT;AAUO,2BAA2B,iBAA8B;AAC9D,SAAO,KAAK,UAAU,iBAAiB,CAAC,KAAK,UAAU;AACrD,QAAI,OAAO,UAAU,UAAU;AAC7B,aAAO,OAAO,KAAK;AAAA,IACrB;AAEA,WAAO;AAAA,EACT,CAAC;AACH;",
  "names": []
}
