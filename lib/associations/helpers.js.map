{
  "version": 3,
  "sources": ["../../src/associations/helpers.js"],
  "sourcesContent": ["'use strict';\n\nexport function checkNamingCollision(association) {\n  if (Object.prototype.hasOwnProperty.call(association.source.rawAttributes, association.as)) {\n    throw new Error(\n      `Naming collision between attribute '${association.as}'`\n      + ` and association '${association.as}' on model ${association.source.name}`\n      + '. To remedy this, change either foreignKey or as in your association definition',\n    );\n  }\n}\n\nexport function addForeignKeyConstraints(newAttribute, source, target, options, key) {\n  // FK constraints are opt-in: users must either set `foreignKeyConstraints`\n  // on the association, or request an `onDelete` or `onUpdate` behavior\n\n  if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {\n    // Find primary keys: composite keys not supported with this approach\n    const primaryKeys = Object.keys(source.primaryKeys)\n      .map(primaryKeyAttribute => source.rawAttributes[primaryKeyAttribute].field || primaryKeyAttribute);\n\n    if (primaryKeys.length === 1 || !primaryKeys.includes(key)) {\n      newAttribute.references = {\n        model: source.getTableName(),\n        key: key || primaryKeys[0],\n      };\n\n      newAttribute.onDelete = options.onDelete;\n      newAttribute.onUpdate = options.onUpdate;\n    }\n  }\n}\n\n/**\n * Mixin (inject) association methods to model prototype\n *\n * @private\n *\n * @param {object} association instance\n * @param {object} obj Model prototype\n * @param {Array} methods Method names to inject\n * @param {object} aliases Mapping between model and association method names\n *\n */\nexport function mixinMethods(association, obj, methods, aliases) {\n  aliases = aliases || {};\n\n  for (const method of methods) {\n    // don't override custom methods\n    if (!Object.prototype.hasOwnProperty.call(obj, association.accessors[method])) {\n      const realMethod = aliases[method] || method;\n\n      obj[association.accessors[method]] = function (...params) {\n        return association[realMethod](this, ...params);\n      };\n    }\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEO,8BAA8B,aAAa;AAChD,MAAI,OAAO,UAAU,eAAe,KAAK,YAAY,OAAO,eAAe,YAAY,EAAE,GAAG;AAC1F,UAAM,IAAI,MACR,uCAAuC,YAAY,wBAC5B,YAAY,gBAAgB,YAAY,OAAO,qFAExE;AAAA,EACF;AACF;AAEO,kCAAkC,cAAc,QAAQ,QAAQ,SAAS,KAAK;AAInF,MAAI,QAAQ,wBAAwB,QAAQ,YAAY,QAAQ,UAAU;AAExE,UAAM,cAAc,OAAO,KAAK,OAAO,WAAW,EAC/C,IAAI,yBAAuB,OAAO,cAAc,qBAAqB,SAAS,mBAAmB;AAEpG,QAAI,YAAY,WAAW,KAAK,CAAC,YAAY,SAAS,GAAG,GAAG;AAC1D,mBAAa,aAAa;AAAA,QACxB,OAAO,OAAO,aAAa;AAAA,QAC3B,KAAK,OAAO,YAAY;AAAA,MAC1B;AAEA,mBAAa,WAAW,QAAQ;AAChC,mBAAa,WAAW,QAAQ;AAAA,IAClC;AAAA,EACF;AACF;AAaO,sBAAsB,aAAa,KAAK,SAAS,SAAS;AAC/D,YAAU,WAAW,CAAC;AAEtB,aAAW,UAAU,SAAS;AAE5B,QAAI,CAAC,OAAO,UAAU,eAAe,KAAK,KAAK,YAAY,UAAU,OAAO,GAAG;AAC7E,YAAM,aAAa,QAAQ,WAAW;AAEtC,UAAI,YAAY,UAAU,WAAW,YAAa,QAAQ;AACxD,eAAO,YAAY,YAAY,MAAM,GAAG,MAAM;AAAA,MAChD;AAAA,IACF;AAAA,EACF;AACF;",
  "names": []
}
