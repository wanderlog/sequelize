{
  "version": 3,
  "sources": ["../../../src/dialects/mssql/query-generator.js"],
  "sourcesContent": ["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst DataTypes = require('../../data-types');\nconst { TableHints } = require('../../table-hints');\nconst { AbstractQueryGenerator } = require('../abstract/query-generator');\nconst randomBytes = require('crypto').randomBytes;\nconst semver = require('semver');\nconst { Op } = require('../../operators');\n\n/* istanbul ignore next */\nfunction throwMethodUndefined(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n}\n\nexport class MsSqlQueryGenerator extends AbstractQueryGenerator {\n  createDatabaseQuery(databaseName, options) {\n    options = { collate: null, ...options };\n\n    const collation = options.collate ? `COLLATE ${this.escape(options.collate)}` : '';\n\n    return [\n      'IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')',\n      'BEGIN',\n      'CREATE DATABASE', this.quoteIdentifier(databaseName),\n      `${collation};`,\n      'END;',\n    ].join(' ');\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return [\n      'IF EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')',\n      'BEGIN',\n      'DROP DATABASE', this.quoteIdentifier(databaseName), ';',\n      'END;',\n    ].join(' ');\n  }\n\n  createSchema(schema) {\n    return [\n      'IF NOT EXISTS (SELECT schema_name',\n      'FROM information_schema.schemata',\n      'WHERE schema_name =', wrapSingleQuote(schema), ')',\n      'BEGIN',\n      'EXEC sp_executesql N\\'CREATE SCHEMA',\n      this.quoteIdentifier(schema),\n      ';\\'',\n      'END;',\n    ].join(' ');\n  }\n\n  dropSchema(schema) {\n    // Mimics Postgres CASCADE, will drop objects belonging to the schema\n    const quotedSchema = wrapSingleQuote(schema);\n\n    return [\n      'IF EXISTS (SELECT schema_name',\n      'FROM information_schema.schemata',\n      'WHERE schema_name =', quotedSchema, ')',\n      'BEGIN',\n      'DECLARE @id INT, @ms_sql NVARCHAR(2000);',\n      'DECLARE @cascade TABLE (',\n      'id INT NOT NULL IDENTITY PRIMARY KEY,',\n      'ms_sql NVARCHAR(2000) NOT NULL );',\n      'INSERT INTO @cascade ( ms_sql )',\n      'SELECT CASE WHEN o.type IN (\\'F\\',\\'PK\\')',\n      'THEN N\\'ALTER TABLE [\\'+ s.name + N\\'].[\\' + p.name + N\\'] DROP CONSTRAINT [\\' + o.name + N\\']\\'',\n      'ELSE N\\'DROP TABLE [\\'+ s.name + N\\'].[\\' + o.name + N\\']\\' END',\n      'FROM sys.objects o',\n      'JOIN sys.schemas s on o.schema_id = s.schema_id',\n      'LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id',\n      'WHERE o.type IN (\\'F\\', \\'PK\\', \\'U\\') AND s.name = ', quotedSchema,\n      'ORDER BY o.type ASC;',\n      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',\n      'WHILE @id IS NOT NULL',\n      'BEGIN',\n      'BEGIN TRY EXEC sp_executesql @ms_sql; END TRY',\n      'BEGIN CATCH BREAK; THROW; END CATCH;',\n      'DELETE FROM @cascade WHERE id = @id;',\n      'SELECT @id = NULL, @ms_sql = NULL;',\n      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',\n      'END',\n      'EXEC sp_executesql N\\'DROP SCHEMA', this.quoteIdentifier(schema), ';\\'',\n      'END;',\n    ].join(' ');\n  }\n\n  showSchemasQuery() {\n    return [\n      'SELECT \"name\" as \"schema_name\" FROM sys.schemas as s',\n      'WHERE \"s\".\"name\" NOT IN (',\n      '\\'INFORMATION_SCHEMA\\', \\'dbo\\', \\'guest\\', \\'sys\\', \\'archive\\'',\n      ')', 'AND', '\"s\".\"name\" NOT LIKE', '\\'db_%\\'',\n    ].join(' ');\n  }\n\n  versionQuery() {\n    // Uses string manipulation to convert the MS Maj.Min.Patch.Build to semver Maj.Min.Patch\n    return [\n      'DECLARE @ms_ver NVARCHAR(20);',\n      'SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY(\\'ProductVersion\\')));',\n      'SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX(\\'.\\', @ms_ver)+1, 20)) AS \\'version\\'',\n    ].join(' ');\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attributesClauseParts = [];\n\n    let commentStr = '';\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        let dataType = attributes[attr];\n        let match;\n\n        if (dataType.includes('COMMENT ')) {\n          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n          const commentText = commentMatch[2].replace('COMMENT', '').trim();\n          commentStr += this.commentTemplate(commentText, tableName, attr);\n          // remove comment related substring from dataType\n          dataType = commentMatch[1];\n        }\n\n        if (dataType.includes('PRIMARY KEY')) {\n          primaryKeys.push(attr);\n\n          if (dataType.includes('REFERENCES')) {\n            // MSSQL doesn't support inline REFERENCES declarations: move to the end\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n            foreignKeys[attr] = match[2];\n          } else {\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n          }\n        } else if (dataType.includes('REFERENCES')) {\n          // MSSQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n        }\n      }\n    }\n\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n          }\n\n          attributesClauseParts.push(`CONSTRAINT ${\n            this.quoteIdentifier(indexName)\n          } UNIQUE (${\n            columns.fields.map(field => this.quoteIdentifier(field)).join(', ')\n          })`);\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClauseParts.push(`PRIMARY KEY (${pkString})`);\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClauseParts.push(`FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`);\n      }\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n\n    return Utils.joinSQLFragments([\n      `IF OBJECT_ID('${quotedTableName}', 'U') IS NULL`,\n      `CREATE TABLE ${quotedTableName} (${attributesClauseParts.join(', ')})`,\n      ';',\n      commentStr,\n    ]);\n  }\n\n  describeTableQuery(tableName, schema) {\n    let sql = [\n      'SELECT',\n      'c.COLUMN_NAME AS \\'Name\\',',\n      'c.DATA_TYPE AS \\'Type\\',',\n      'c.CHARACTER_MAXIMUM_LENGTH AS \\'Length\\',',\n      'c.IS_NULLABLE as \\'IsNull\\',',\n      'COLUMN_DEFAULT AS \\'Default\\',',\n      'pk.CONSTRAINT_TYPE AS \\'Constraint\\',',\n      'COLUMNPROPERTY(OBJECT_ID(c.TABLE_SCHEMA+\\'.\\'+c.TABLE_NAME), c.COLUMN_NAME, \\'IsIdentity\\') as \\'IsIdentity\\',',\n      'CAST(prop.value AS NVARCHAR) AS \\'Comment\\'',\n      'FROM',\n      'INFORMATION_SCHEMA.TABLES t',\n      'INNER JOIN',\n      'INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA',\n      'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ',\n      'cu.column_name, tc.CONSTRAINT_TYPE ',\n      'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc ',\n      'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE  cu ',\n      'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ',\n      'and tc.constraint_name=cu.constraint_name ',\n      'and tc.CONSTRAINT_TYPE=\\'PRIMARY KEY\\') pk ',\n      'ON pk.table_schema=c.table_schema ',\n      'AND pk.table_name=c.table_name ',\n      'AND pk.column_name=c.column_name ',\n      'INNER JOIN sys.columns AS sc',\n      'ON sc.object_id = object_id(t.table_schema + \\'.\\' + t.table_name) AND sc.name = c.column_name',\n      'LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id',\n      'AND prop.minor_id = sc.column_id',\n      'AND prop.name = \\'MS_Description\\'',\n      'WHERE t.TABLE_NAME =', wrapSingleQuote(tableName),\n    ].join(' ');\n\n    if (schema) {\n      sql += `AND t.TABLE_SCHEMA =${wrapSingleQuote(schema)}`;\n    }\n\n    return sql;\n  }\n\n  renameTableQuery(before, after) {\n    return `EXEC sp_rename ${this.quoteTable(before)}, ${this.quoteTable(after)};`;\n  }\n\n  showTablesQuery() {\n    return 'SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \\'BASE TABLE\\';';\n  }\n\n  dropTableQuery(tableName) {\n    const quoteTbl = this.quoteTable(tableName);\n\n    return Utils.joinSQLFragments([\n      `IF OBJECT_ID('${quoteTbl}', 'U') IS NOT NULL`,\n      'DROP TABLE',\n      quoteTbl,\n      ';',\n    ]);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    // FIXME: attributeToSQL SHOULD be using attributes in addColumnQuery\n    //        but instead we need to pass the key along as the field here\n    dataType.field = key;\n    let commentStr = '';\n\n    if (dataType.comment && _.isString(dataType.comment)) {\n      commentStr = this.commentTemplate(dataType.comment, table, key);\n      // attributeToSQL will try to include `COMMENT 'Comment Text'` when it returns if the comment key\n      // is present. This is needed for createTable statement where that part is extracted with regex.\n      // Here we can intercept the object and remove comment property since we have the original object.\n      delete dataType.comment;\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(table),\n      'ADD',\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, { context: 'addColumn' }),\n      ';',\n      commentStr,\n    ]);\n  }\n\n  commentTemplate(comment, table, column) {\n    return ' EXEC sp_addextendedproperty '\n        + `@name = N'MS_Description', @value = ${this.escape(comment)}, `\n        + '@level0type = N\\'Schema\\', @level0name = \\'dbo\\', '\n        + `@level1type = N'Table', @level1name = ${this.quoteTable(table)}, `\n        + `@level2type = N'Column', @level2name = ${this.quoteIdentifier(column)};`;\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP COLUMN',\n      this.quoteIdentifier(attributeName),\n      ';',\n    ]);\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n    let commentString = '';\n\n    for (const attributeName in attributes) {\n      const quotedAttrName = this.quoteIdentifier(attributeName);\n      let definition = attributes[attributeName];\n      if (definition.includes('COMMENT ')) {\n        const commentMatch = definition.match(/^(.+) (COMMENT.*)$/);\n        const commentText = commentMatch[2].replace('COMMENT', '').trim();\n        commentString += this.commentTemplate(commentText, tableName, attributeName);\n        // remove comment related substring from dataType\n        definition = commentMatch[1];\n      }\n\n      if (definition.includes('REFERENCES')) {\n        constraintString.push(`FOREIGN KEY (${quotedAttrName}) ${definition.replace(/.+?(?=REFERENCES)/, '')}`);\n      } else {\n        attrString.push(`${quotedAttrName} ${definition}`);\n      }\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      attrString.length && `ALTER COLUMN ${attrString.join(', ')}`,\n      constraintString.length && `ADD ${constraintString.join(', ')}`,\n      ';',\n      commentString,\n    ]);\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n\n    return Utils.joinSQLFragments([\n      'EXEC sp_rename',\n      `'${this.quoteTable(tableName)}.${attrBefore}',`,\n      `'${newName}',`,\n      '\\'COLUMN\\'',\n      ';',\n    ]);\n  }\n\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    const quotedTable = this.quoteTable(tableName);\n    options = options || {};\n    attributes = attributes || {};\n\n    const tuples = [];\n    const allAttributes = [];\n    const allQueries = [];\n\n    let needIdentityInsertWrapper = false;\n    let outputFragment = '';\n\n    if (options.returning) {\n      const returnValues = this.generateReturnValues(attributes, options);\n\n      outputFragment = returnValues.outputFragment;\n    }\n\n    const emptyQuery = `INSERT INTO ${quotedTable}${outputFragment} DEFAULT VALUES`;\n\n    for (const attrValueHash of attrValueHashes) {\n      // special case for empty objects with primary keys\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        allQueries.push(emptyQuery);\n        continue;\n      }\n\n      // normal case\n      _.forOwn(attrValueHash, (value, key) => {\n        if (value !== null && attributes[key] && attributes[key].autoIncrement) {\n          needIdentityInsertWrapper = true;\n        }\n\n        if (!allAttributes.includes(key)) {\n          if (value === null && attributes[key] && attributes[key].autoIncrement) {\n            return;\n          }\n\n          allAttributes.push(key);\n        }\n      });\n    }\n\n    if (allAttributes.length > 0) {\n      for (const attrValueHash of attrValueHashes) {\n        tuples.push(`(${\n          allAttributes.map(key => this.escape(attrValueHash[key])).join(',')\n        })`);\n      }\n\n      const quotedAttributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');\n      allQueries.push(tupleStr => `INSERT INTO ${quotedTable} (${quotedAttributes})${outputFragment} VALUES ${tupleStr};`);\n    }\n\n    const commands = [];\n    let offset = 0;\n    const batch = Math.floor(250 / (allAttributes.length + 1)) + 1;\n    while (offset < Math.max(tuples.length, 1)) {\n      const tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));\n      let generatedQuery = allQueries.map(v => (typeof v === 'string' ? v : v(tupleStr))).join(';');\n      if (needIdentityInsertWrapper) {\n        generatedQuery = `SET IDENTITY_INSERT ${quotedTable} ON; ${generatedQuery}; SET IDENTITY_INSERT ${quotedTable} OFF;`;\n      }\n\n      commands.push(generatedQuery);\n      offset += batch;\n    }\n\n    return commands.join(';');\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n    if (options.limit) {\n      const updateArgs = `UPDATE TOP(${this.escape(options.limit)})`;\n      sql.query = sql.query.replace('UPDATE', updateArgs);\n    }\n\n    return sql;\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model) {\n    const targetTableAlias = this.quoteTable(`${tableName}_target`);\n    const sourceTableAlias = this.quoteTable(`${tableName}_source`);\n    const primaryKeysAttrs = [];\n    const identityAttrs = [];\n    const uniqueAttrs = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n    let needIdentityInsertWrapper = false;\n\n    // Obtain primaryKeys, uniquekeys and identity attrs from rawAttributes as model is not passed\n    for (const key in model.rawAttributes) {\n      if (model.rawAttributes[key].primaryKey) {\n        primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n      }\n\n      if (model.rawAttributes[key].unique) {\n        uniqueAttrs.push(model.rawAttributes[key].field || key);\n      }\n\n      if (model.rawAttributes[key].autoIncrement) {\n        identityAttrs.push(model.rawAttributes[key].field || key);\n      }\n    }\n\n    // Add unique indexes defined by indexes option to uniqueAttrs\n    for (const index of model._indexes) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const fieldName = typeof field === 'string' ? field : field.name || field.attribute;\n          if (!uniqueAttrs.includes(fieldName) && model.rawAttributes[fieldName]) {\n            uniqueAttrs.push(fieldName);\n          }\n        }\n      }\n    }\n\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map(key => this.quoteIdentifier(key)).join(', ');\n    const insertValuesEscaped = insertKeys.map(key => this.escape(insertValues[key])).join(', ');\n    const sourceTableQuery = `VALUES(${insertValuesEscaped})`; // Virtual Table\n    let joinCondition;\n\n    // IDENTITY_INSERT Condition\n    for (const key of identityAttrs) {\n      if (insertValues[key] && insertValues[key] !== null) {\n        needIdentityInsertWrapper = true;\n        /*\n         * IDENTITY_INSERT Column Cannot be updated, only inserted\n         * http://stackoverflow.com/a/30176254/2254360\n         */\n      }\n    }\n\n    // Filter NULL Clauses\n    const clauses = where[Op.or].filter(clause => {\n      let valid = true;\n      /*\n       * Exclude NULL Composite PK/UK. Partial Composite clauses should also be excluded as it doesn't guarantee a single row\n       */\n      for (const key in clause) {\n        if (typeof clause[key] === 'undefined' || clause[key] == null) {\n          valid = false;\n          break;\n        }\n      }\n\n      return valid;\n    });\n\n    /*\n     * Generate ON condition using PK(s).\n     * If not, generate using UK(s). Else throw error\n     */\n    const getJoinSnippet = array => {\n      return array.map(key => {\n        key = this.quoteIdentifier(key);\n\n        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;\n      });\n    };\n\n    if (clauses.length === 0) {\n      throw new Error('Primary Key or Unique key should be passed to upsert query');\n    } else {\n      // Search for primary key attribute in clauses -- Model can have two separate unique keys\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n        if (primaryKeysAttrs.includes(keys[0])) {\n          joinCondition = getJoinSnippet(primaryKeysAttrs).join(' AND ');\n          break;\n        }\n      }\n\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueAttrs).join(' AND ');\n      }\n    }\n\n    // Remove the IDENTITY_INSERT Column from update\n    const filteredUpdateClauses = updateKeys.filter(key => !identityAttrs.includes(key))\n      .map(key => {\n        const value = this.escape(updateValues[key]);\n        key = this.quoteIdentifier(key);\n\n        return `${targetTableAlias}.${key} = ${value}`;\n      });\n    const updateSnippet = filteredUpdateClauses.length > 0 ? `WHEN MATCHED THEN UPDATE SET ${filteredUpdateClauses.join(', ')}` : '';\n\n    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;\n\n    let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;\n    query += ` ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;\n    if (needIdentityInsertWrapper) {\n      query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;\n    }\n\n    return query;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    const whereClause = this.getWhereConditions(where, null, model, options);\n\n    return Utils.joinSQLFragments([\n      'DELETE',\n      options.limit && `TOP(${this.escape(options.limit)})`,\n      'FROM',\n      table,\n      whereClause && `WHERE ${whereClause}`,\n      ';',\n      'SELECT @@ROWCOUNT AS AFFECTEDROWS',\n      ';',\n    ]);\n  }\n\n  showIndexesQuery(tableName) {\n    return `EXEC sys.sp_helpindex @objname = N'${this.quoteTable(tableName)}';`;\n  }\n\n  showConstraintsQuery(tableName) {\n    return `EXEC sp_helpconstraint @objname = ${this.escape(this.quoteTable(tableName))};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX ${this.quoteIdentifiers(indexName)} ON ${this.quoteIdentifiers(tableName)}`;\n  }\n\n  attributeToSQL(attribute) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute,\n      };\n    }\n\n    // handle self referential constraints\n    if (attribute.references && attribute.Model && attribute.Model.tableName === attribute.references.model) {\n      this.sequelize.log('MSSQL does not support self referencial constraints, '\n          + 'we will remove it but we recommend restructuring your query');\n      attribute.onDelete = '';\n      attribute.onUpdate = '';\n    }\n\n    let template;\n\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) {\n        attribute.values = attribute.type.values;\n      }\n\n      // enums are a special case\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map(value => {\n        return this.escape(value);\n      }).join(', ')}))`;\n\n      return template;\n    }\n\n    template = attribute.type.toString();\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ' NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' IDENTITY(1,1)';\n    }\n\n    // Blobs/texts cannot have a defaultValue\n    if (attribute.type !== 'TEXT' && attribute.type._binary !== true\n        && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    if (attribute.comment && typeof attribute.comment === 'string') {\n      template += ` COMMENT ${attribute.comment}`;\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n    const existingConstraints = [];\n    let key;\n    let attribute;\n\n    for (key in attributes) {\n      attribute = attributes[key];\n\n      if (attribute.references) {\n        if (existingConstraints.includes(attribute.references.model.toString())) {\n          // no cascading constraints to a table more than once\n          attribute.onDelete = '';\n          attribute.onUpdate = '';\n        } else {\n          existingConstraints.push(attribute.references.model.toString());\n\n          // NOTE: this really just disables cascading updates for all\n          //       definitions. Can be made more robust to support the\n          //       few cases where MSSQL actually supports them\n          attribute.onUpdate = '';\n        }\n\n      }\n\n      if (key && !attribute.field) {\n        attribute.field = key;\n      }\n\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  createTrigger() {\n    throwMethodUndefined('createTrigger');\n  }\n\n  dropTrigger() {\n    throwMethodUndefined('dropTrigger');\n  }\n\n  renameTrigger() {\n    throwMethodUndefined('renameTrigger');\n  }\n\n  createFunction() {\n    throwMethodUndefined('createFunction');\n  }\n\n  dropFunction() {\n    throwMethodUndefined('dropFunction');\n  }\n\n  renameFunction() {\n    throwMethodUndefined('renameFunction');\n  }\n\n  /**\n   * Generate common SQL prefix for ForeignKeysQuery.\n   *\n   * @param {string} catalogName\n   * @returns {string}\n   */\n  _getForeignKeysQueryPrefix(catalogName) {\n    return `SELECT constraint_name = OBJ.NAME, constraintName = OBJ.NAME, ${\n      catalogName ? `constraintCatalog = '${catalogName}', ` : ''\n    }constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), `\n      + 'tableName = TB.NAME, '\n      + `tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), ${\n        catalogName ? `tableCatalog = '${catalogName}', ` : ''\n      }columnName = COL.NAME, `\n      + `referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), ${\n        catalogName ? `referencedCatalog = '${catalogName}', ` : ''\n      }referencedTableName = RTB.NAME, `\n      + 'referencedColumnName = RCOL.NAME '\n      + 'FROM sys.foreign_key_columns FKC '\n      + 'INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID '\n      + 'INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID '\n      + 'INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID '\n      + 'INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID '\n      + 'INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID';\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys details of a table.\n   *\n   * @param {string|object} table\n   * @param {string} catalogName database name\n   * @returns {string}\n   */\n  getForeignKeysQuery(table, catalogName) {\n    const tableName = table.tableName || table;\n    let sql = `${this._getForeignKeysQueryPrefix(catalogName)\n    } WHERE TB.NAME =${wrapSingleQuote(tableName)}`;\n\n    if (table.schema) {\n      sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;\n    }\n\n    return sql;\n  }\n\n  getForeignKeyQuery(table, attributeName) {\n    const tableName = table.tableName || table;\n\n    return Utils.joinSQLFragments([\n      this._getForeignKeysQueryPrefix(),\n      'WHERE',\n      `TB.NAME =${wrapSingleQuote(tableName)}`,\n      'AND',\n      `COL.NAME =${wrapSingleQuote(attributeName)}`,\n      table.schema && `AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`,\n    ]);\n  }\n\n  getPrimaryKeyConstraintQuery(table, attributeName) {\n    const tableName = wrapSingleQuote(table.tableName || table);\n\n    return Utils.joinSQLFragments([\n      'SELECT K.TABLE_NAME AS tableName,',\n      'K.COLUMN_NAME AS columnName,',\n      'K.CONSTRAINT_NAME AS constraintName',\n      'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C',\n      'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K',\n      'ON C.TABLE_NAME = K.TABLE_NAME',\n      'AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG',\n      'AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA',\n      'AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME',\n      'WHERE C.CONSTRAINT_TYPE = \\'PRIMARY KEY\\'',\n      `AND K.COLUMN_NAME = ${wrapSingleQuote(attributeName)}`,\n      `AND K.TABLE_NAME = ${tableName}`,\n      ';',\n    ]);\n  }\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP',\n      this.quoteIdentifier(foreignKey),\n    ]);\n  }\n\n  getDefaultConstraintQuery(tableName, attributeName) {\n    const quotedTable = this.quoteTable(tableName);\n\n    return Utils.joinSQLFragments([\n      'SELECT name FROM sys.default_constraints',\n      `WHERE PARENT_OBJECT_ID = OBJECT_ID('${quotedTable}', 'U')`,\n      `AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('${attributeName}')`,\n      `AND object_id = OBJECT_ID('${quotedTable}', 'U'))`,\n      ';',\n    ]);\n  }\n\n  dropConstraintQuery(tableName, constraintName) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP CONSTRAINT',\n      this.quoteIdentifier(constraintName),\n      ';',\n    ]);\n  }\n\n  setIsolationLevelQuery() {}\n\n  generateTransactionId() {\n    return randomBytes(10).toString('hex');\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return 'BEGIN TRANSACTION;';\n  }\n\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return 'COMMIT TRANSACTION;';\n  }\n\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return 'ROLLBACK TRANSACTION;';\n  }\n\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {\n    this._throwOnEmptyAttributes(attributes, { modelName: model && model.name, as: mainTableAs });\n\n    const dbVersion = this.sequelize.options.databaseVersion;\n    const isSQLServer2008 = semver.valid(dbVersion) && semver.lt(dbVersion, '11.0.0');\n\n    if (isSQLServer2008 && options.offset) {\n      // For earlier versions of SQL server, we need to nest several queries\n      // in order to emulate the OFFSET behavior.\n      //\n      // 1. The outermost query selects all items from the inner query block.\n      //    This is due to a limitation in SQL server with the use of computed\n      //    columns (e.g. SELECT ROW_NUMBER()...AS x) in WHERE clauses.\n      // 2. The next query handles the LIMIT and OFFSET behavior by getting\n      //    the TOP N rows of the query where the row number is > OFFSET\n      // 3. The innermost query is the actual set we want information from\n\n      const offset = options.offset || 0;\n      const isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n      let orders = { mainQueryOrder: [] };\n      if (options.order) {\n        orders = this.getQueryOrders(options, model, isSubQuery);\n      }\n\n      if (orders.mainQueryOrder.length === 0) {\n        orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));\n      }\n\n      const tmpTable = mainTableAs || 'OffsetTable';\n\n      if (options.include) {\n        const subQuery = options.subQuery === undefined ? options.limit && options.hasMultiAssociation : options.subQuery;\n        const mainTable = {\n          name: mainTableAs,\n          quotedName: null,\n          as: null,\n          model,\n        };\n        const topLevelInfo = {\n          names: mainTable,\n          options,\n          subQuery,\n        };\n\n        let mainJoinQueries = [];\n        for (const include of options.include) {\n          if (include.separate) {\n            continue;\n          }\n\n          const joinQueries = this.generateInclude(include, { externalAs: mainTableAs, internalAs: mainTableAs }, topLevelInfo);\n          mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n        }\n\n        return Utils.joinSQLFragments([\n          'SELECT TOP 100 PERCENT',\n          attributes.join(', '),\n          'FROM (',\n          [\n            'SELECT',\n            options.limit && `TOP ${options.limit}`,\n            '* FROM (',\n            [\n              'SELECT ROW_NUMBER() OVER (',\n              [\n                'ORDER BY',\n                orders.mainQueryOrder.join(', '),\n              ],\n              `) as row_num, ${tmpTable}.* FROM (`,\n              [\n                'SELECT DISTINCT',\n                `${tmpTable}.* FROM ${tables} AS ${tmpTable}`,\n                mainJoinQueries,\n                where && `WHERE ${where}`,\n              ],\n              `) AS ${tmpTable}`,\n            ],\n            `) AS ${tmpTable} WHERE row_num > ${offset}`,\n          ],\n          `) AS ${tmpTable}`,\n        ]);\n      }\n\n      return Utils.joinSQLFragments([\n        'SELECT TOP 100 PERCENT',\n        attributes.join(', '),\n        'FROM (',\n        [\n          'SELECT',\n          options.limit && `TOP ${options.limit}`,\n          '* FROM (',\n          [\n            'SELECT ROW_NUMBER() OVER (',\n            [\n              'ORDER BY',\n              orders.mainQueryOrder.join(', '),\n            ],\n            `) as row_num, * FROM ${tables} AS ${tmpTable}`,\n            where && `WHERE ${where}`,\n          ],\n          `) AS ${tmpTable} WHERE row_num > ${offset}`,\n        ],\n        `) AS ${tmpTable}`,\n      ]);\n    }\n\n    return Utils.joinSQLFragments([\n      'SELECT',\n      isSQLServer2008 && options.limit && `TOP ${options.limit}`,\n      attributes.join(', '),\n      `FROM ${tables}`,\n      mainTableAs && `AS ${mainTableAs}`,\n      options.tableHint && TableHints[options.tableHint] && `WITH (${TableHints[options.tableHint]})`,\n    ]);\n  }\n\n  addLimitAndOffset(options, model) {\n    // Skip handling of limit and offset as postfixes for older SQL Server versions\n    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, '11.0.0')) {\n      return '';\n    }\n\n    const offset = options.offset || 0;\n    const isSubQuery = options.subQuery === undefined\n      ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation\n      : options.subQuery;\n\n    let fragment = '';\n    let orders = {};\n\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n\n    if (options.limit || options.offset) {\n      // TODO: document why this is adding the primary key of the model in ORDER BY\n      //  if options.include is set\n      if (!options.order || options.order.length === 0 || options.include && orders.subQueryOrder.length === 0) {\n        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(model.primaryKeyField)}`;\n        if (!options.order || options.order.length === 0) {\n          fragment += ` ORDER BY ${tablePkFragment}`;\n        } else {\n          const orderFieldNames = _.map(options.order, order => order[0]);\n          const primaryKeyFieldAlreadyPresent = _.includes(orderFieldNames, model.primaryKeyField);\n\n          if (!primaryKeyFieldAlreadyPresent) {\n            fragment += options.order && !isSubQuery ? ', ' : ' ORDER BY ';\n            fragment += tablePkFragment;\n          }\n        }\n      }\n\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n\n    return fragment;\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  /**\n   * Quote identifier in sql clause\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    return `[${identifier.replace(/['[\\]]+/g, '')}]`;\n  }\n}\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(Utils.removeTicks(identifier, '\\''), '\\'');\n}\n"],
  "mappings": "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",
  "names": []
}
